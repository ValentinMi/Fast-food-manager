{"ast":null,"code":"import _objectSpread from \"/home/mower/projets/exercice/redux-test/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport * as orderConst from \"../const/order.const\";\nconst initState = {\n  orders: {\n    pendingOrder: [],\n    payedOrders: []\n  }\n};\n\nconst orderReducer = (state = initState, action) => {\n  // Clone orders\n  let newOrders = _objectSpread({}, state.orders); // Destructure action\n\n\n  const type = action.type,\n        payload = action.payload;\n\n  switch (type) {\n    // ADD PRODUCT IN ORDER LIST\n    case orderConst.ADD_PRODUCT_TO_ORDER:\n      // Check if product is already in order\n      let index = newOrders.pendingOrder.findIndex(p => p.name === payload.product.name);\n\n      if (index !== -1) {\n        // Check stock\n        if (newOrders.pendingOrder[index].quantity + payload.quantity > payload.product.stock) {\n          // If request quantity is superior as stock => alert\n          alert(\"Il ne reste que \".concat(payload.product.stock, \" \").concat(payload.product.name));\n          return state;\n        } // Add the quantity to existing product and ajust the price\n\n\n        newOrders.pendingOrder[index].quantity += payload.quantity;\n        newOrders.pendingOrder[index].price += payload.product.price * payload.quantity;\n        return _objectSpread({}, state, {\n          orders: newOrders\n        });\n      } else {\n        // Push product in pendingOrder\n        newOrders.pendingOrder.push({\n          name: payload.product.name,\n          quantity: payload.quantity,\n          price: payload.price * payload.quantity\n        });\n        return _objectSpread({}, state, {\n          orders: newOrders\n        });\n      }\n\n    // REMOVE PRODUCT FROM ORDER LIST\n\n    case orderConst.REMOVE_PRODUCT_FROM_ORDER:\n      // Remove it from pendingOrder\n      newOrders.pendingOrder = newOrders.pendingOrder.filter(p => p !== state.orders.pendingOrder[payload.index]);\n      return _objectSpread({}, state, {\n        orders: newOrders\n      });\n    // BUY THE ORDER\n\n    case orderConst.BUY_ORDER:\n      // Clear pendingOrder & add it to payedOrder\n      newOrders.payedOrders.push(newOrders.pendingOrder);\n      newOrders.pendingOrder = [];\n      return _objectSpread({}, state, {\n        orders: newOrders\n      });\n    // SEND THE ORDER\n\n    case orderConst.SEND_ORDER:\n      newOrders.payedOrders = newOrders.payedOrders.filter(p => p !== state.orders.payedOrders[payload.index]);\n      return _objectSpread({}, state, {\n        orders: newOrders\n      });\n\n    default:\n      return state;\n  }\n};\n\nexport default orderReducer;","map":{"version":3,"sources":["/home/mower/projets/exercice/redux-test/client/src/reducers/order.reducer.js"],"names":["orderConst","initState","orders","pendingOrder","payedOrders","orderReducer","state","action","newOrders","type","payload","ADD_PRODUCT_TO_ORDER","index","findIndex","p","name","product","quantity","stock","alert","price","push","REMOVE_PRODUCT_FROM_ORDER","filter","BUY_ORDER","SEND_ORDER"],"mappings":"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","sourcesContent":["import * as orderConst from \"../const/order.const\";\n\nconst initState = {\n  orders: {\n    pendingOrder: [],\n    payedOrders: []\n  }\n};\n\nconst orderReducer = (state = initState, action) => {\n  // Clone orders\n  let newOrders = { ...state.orders };\n\n  // Destructure action\n  const { type, payload } = action;\n\n  switch (type) {\n    // ADD PRODUCT IN ORDER LIST\n    case orderConst.ADD_PRODUCT_TO_ORDER:\n      // Check if product is already in order\n      let index = newOrders.pendingOrder.findIndex(\n        p => p.name === payload.product.name\n      );\n      if (index !== -1) {\n        // Check stock\n        if (\n          newOrders.pendingOrder[index].quantity + payload.quantity >\n          payload.product.stock\n        ) {\n          // If request quantity is superior as stock => alert\n          alert(\n            `Il ne reste que ${payload.product.stock} ${payload.product.name}`\n          );\n          return state;\n        }\n        // Add the quantity to existing product and ajust the price\n        newOrders.pendingOrder[index].quantity += payload.quantity;\n        newOrders.pendingOrder[index].price +=\n          payload.product.price * payload.quantity;\n        return { ...state, orders: newOrders };\n      } else {\n        // Push product in pendingOrder\n        newOrders.pendingOrder.push({\n          name: payload.product.name,\n          quantity: payload.quantity,\n          price: payload.price * payload.quantity\n        });\n        return { ...state, orders: newOrders };\n      }\n\n    // REMOVE PRODUCT FROM ORDER LIST\n    case orderConst.REMOVE_PRODUCT_FROM_ORDER:\n      // Remove it from pendingOrder\n      newOrders.pendingOrder = newOrders.pendingOrder.filter(\n        p => p !== state.orders.pendingOrder[payload.index]\n      );\n      return { ...state, orders: newOrders };\n\n    // BUY THE ORDER\n    case orderConst.BUY_ORDER:\n      // Clear pendingOrder & add it to payedOrder\n      newOrders.payedOrders.push(newOrders.pendingOrder);\n      newOrders.pendingOrder = [];\n      return {\n        ...state,\n        orders: newOrders\n      };\n\n    // SEND THE ORDER\n    case orderConst.SEND_ORDER:\n      newOrders.payedOrders = newOrders.payedOrders.filter(\n        p => p !== state.orders.payedOrders[payload.index]\n      );\n      return { ...state, orders: newOrders };\n\n    default:\n      return state;\n  }\n};\n\nexport default orderReducer;\n"]},"metadata":{},"sourceType":"module"}